/**
 * Mainly do the parse and compile of shader string
 * Support shader code chunk import and export
 * Support shader semantics
 * http://www.nvidia.com/object/using_sas.html
 * https://github.com/KhronosGroup/collada2json/issues/45
 *
 */
define(function(require) {
    
    'use strict';

    var Base = require("./core/Base");
    var util = require("./core/util");
    var glMatrix = require("glmatrix");
    var _ = require('_');
    var mat2 = glMatrix.mat2;
    var mat3 = glMatrix.mat3;
    var mat4 = glMatrix.mat4;

    var uniformRegex = /uniform\s+(bool|float|int|vec2|vec3|vec4|ivec2|ivec3|ivec4|mat2|mat3|mat4|sampler2D|samplerCube)\s+([\w\,]+)?(\[.*?\])?\s*(:\s*([\S\s]+?))?;/g;
    var attributeRegex = /attribute\s+(float|int|vec2|vec3|vec4)\s+(\w*)\s*(:\s*(\w+))?;/g;
    var defineRegex = /#define\s+(\w+)?(\s+[\w-.]+)?\s*\n/g;

    var uniformTypeMap = {
        "bool" : "1i",
        "int" : "1i",
        "sampler2D" : "t",
        "samplerCube" : "t",
        "float" : "1f",
        "vec2" : "2f",
        "vec3" : "3f",
        "vec4" : "4f",
        "ivec2" : "2i",
        "ivec3" : "3i",
        "ivec4" : "4i",
        "mat2" : "m2",
        "mat3" : "m3",
        "mat4" : "m4"
    }
    var uniformValueConstructor = {
        'bool' : function() {return true;},
        'int' : function() {return 0;},
        'float' : function() {return 0;},
        'sampler2D' : function() {return null;},
        'samplerCube' : function() {return null;},

        'vec2' : function() {return [0, 0];},
        'vec3' : function() {return [0, 0, 0];},
        'vec4' : function() {return [0, 0, 0, 0];},

        'ivec2' : function() {return [0, 0];},
        'ivec3' : function() {return [0, 0, 0];},
        'ivec4' : function() {return [0, 0, 0, 0];},

        'mat2' : function() {return mat2.create();},
        'mat3' : function() {return mat3.create();},
        'mat4' : function() {return mat4.create();},

        'array' : function() {return [];}
    }
    var attribSemantics = [
        'POSITION', 
        'NORMAL',
        'BINORMAL',
        'TANGENT',
        'TEXCOORD',
        'TEXCOORD_0',
        'TEXCOORD_1',
        'COLOR',
        // Skinning
        // https://github.com/KhronosGroup/glTF/blob/master/specification/README.md#semantics
        'JOINT',
        'WEIGHT',
        'SKIN_MATRIX'
    ];
    var matrixSemantics = [
        'WORLD',
        'VIEW',
        'PROJECTION',
        'WORLDVIEW',
        'VIEWPROJECTION',
        'WORLDVIEWPROJECTION',
        'WORLDINVERSE',
        'VIEWINVERSE',
        'PROJECTIONINVERSE',
        'WORLDVIEWINVERSE',
        'VIEWPROJECTIONINVERSE',
        'WORLDVIEWPROJECTIONINVERSE',
        'WORLDTRANSPOSE',
        'VIEWTRANSPOSE',
        'PROJECTIONTRANSPOSE',
        'WORLDVIEWTRANSPOSE',
        'VIEWPROJECTIONTRANSPOSE',
        'WORLDVIEWPROJECTIONTRANSPOSE',
        'WORLDINVERSETRANSPOSE',
        'VIEWINVERSETRANSPOSE',
        'PROJECTIONINVERSETRANSPOSE',
        'WORLDVIEWINVERSETRANSPOSE',
        'VIEWPROJECTIONINVERSETRANSPOSE',
        'WORLDVIEWPROJECTIONINVERSETRANSPOSE',
    ];
    
    var errorShader = {};

    // Enable attribute operation is global to all programs
    // Here saved the list of all enabled attribute index 
    // http://www.mjbshaw.com/2013/03/webgl-fixing-invalidoperation.html
    var enabledAttributeList = {};

    var Shader = Base.derive(function() {

        return {

            __GUID__ : util.genGUID(),

            vertex : "",
            
            fragment : "",

            precision : "mediump",
            // Properties follow will be generated by the program
            attribSemantics : {},
            matrixSemantics : {},
            matrixSemanticKeys : [],

            uniformTemplates : {},
            attributeTemplates : {},

            // Custom defined values in the shader
            vertexDefines : {},
            fragmentDefines : {},
            // Glue code
            // Defines the each type light number in the scene
            // AMBIENT_LIGHT
            // POINT_LIGHT
            // SPOT_LIGHT
            // AREA_LIGHT
            lightNumber : {},

            _uniformList : [],
            // {
            //  enabled : true
            //  shaderType : "vertex",
            // }
            _textureStatus : {},

            _vertexProcessed : "",
            _fragmentProcessed : ""

        }
    }, function() {
        this._updateShaderString();
    }, {

        setVertex : function(str) {
            this.vertex = str;
            this._updateShaderString();
            this.dirty();
        },
        setFragment : function(str) {
            this.fragment = str;
            this._updateShaderString();
            this.dirty();
        },
        bind : function(_gl) {

            this.cache.use(_gl.__GLID__, getCacheSchema);

            if (this.cache.isDirty()) {
                this._updateShaderString();
                this._buildProgram(_gl, this._vertexProcessed, this._fragmentProcessed);
                this.cache.fresh();
            }

            _gl.useProgram(this.cache.get("program"));
        },

        dirty : function() {
            this.cache.dirty();
            for (var i = 0; i < this.cache._caches.length; i++) {
                if (this.cache._caches[i]) {
                    var context = this.cache._caches[i];
                    context["locations"] = {};
                    context["attriblocations"] = {};
                }
            }
        },

        _updateShaderString : function() {

            if (this.vertex !== this._vertexPrev ||
                this.fragment !== this._fragmentPrev) {

                this._parseImport();
                
                this.attribSemantics = {};
                this.matrixSemantics = {};
                this._textureStatus = {};

                this._parseUniforms();
                this._parseAttributes();
                this._parseDefines();

                this._vertexPrev = this.vertex;
                this._fragmentPrev = this.fragment;
            }
            this._addDefine();
        },

        define : function(type, key, val) {
            val = val || null;
            if (type == 'vertex' || type == 'both') {
                if (this.vertexDefines[key] !== val) {
                    this.vertexDefines[key] = val;
                    // Mark as dirty
                    this.dirty();
                }
            }
            if (type == 'fragment' || type == 'both') {
                if (this.fragmentDefines[key] !== val) {
                    this.fragmentDefines[key] = val;
                    // Mark as dirty
                    this.dirty();
                }
            }
        },

        unDefine : function(type, key) {
            switch(type) {
                case "vertex":
                    if (this.isDefined('vertex', key)) {
                        delete this.vertexDefines[key];
                        // Mark as dirty
                        this.dirty();
                    }
                    break;
                case "fragment":
                    if (this.isDefined('fragment', key)) {
                        delete this.fragmentDefines[key];
                        // Mark as dirty
                        this.dirty();
                    }
                    break;
                default:
                    throw new Error("Undefine type must be vertex or fragment");
            }
        },

        isDefined : function(type, key) {
            switch(type) {
                case "vertex":
                    return this.vertexDefines[key] !== undefined;
                case "fragment":
                    return this.fragmentDefines[key] !== undefined;
            }
        },

        getDefine : function(type, key) {
            switch(type) {
                case "vertex":
                    return this.vertexDefines[key];
                case "fragment":
                    return this.fragmentDefines[key];
            }
        },

        enableTexture : function(symbol) {
            var status = this._textureStatus[symbol];
            if (status) {
                var isEnabled = status.enabled;
                if (isEnabled) {
                    // Do nothing
                    return;
                }else{
                    status.enabled = true;
                    this.dirty();
                }
            }
        },

        enableTexturesAll : function() {
            for (var symbol in this._textureStatus) {
                this._textureStatus[symbol].enabled = true;
            }

            this.dirty();
        },

        disableTexture : function(symbol) {
            var status = this._textureStatus[symbol];
            if (status) {
                var isDisabled = ! status.enabled;
                if (isDisabled) {
                    // Do nothing
                    return;
                }else{
                    status.enabled = false;

                    this.dirty();
                }
            }
        },

        disableTexturesAll : function(symbol) {
            for (var symbol in this._textureStatus) {
                this._textureStatus[symbol].enabled = false;
            }

            this.dirty();
        },

        isTextureEnabled : function(symbol) {
            return this._textureStatus[symbol].enabled;
        },

        setUniform : function(_gl, type, symbol, value) {
            var locationMap = this.cache.get("locations");
            var location = locationMap[symbol];
            // Uniform is not existed in the shader
            if (location === null || location === undefined) {
                return;
            }
            switch (type) {
                case 'm4':
                    // The matrix must be created by glmatrix and can pass it directly.
                    _gl.uniformMatrix4fv(location, false, value);
                    break;
                case '2i':
                    _gl.uniform2i(location, value[0], value[1]);
                    break;
                case '2f':
                    _gl.uniform2f(location, value[0], value[1]);
                    break;
                case '3i':
                    _gl.uniform3i(location, value[0], value[1], value[2]);
                    break;
                case '3f':
                    _gl.uniform3f(location, value[0], value[1], value[2]);
                    break;
                case '4i':
                    _gl.uniform4i(location, value[0], value[1], value[2], value[3]);
                    break;
                case '4f':
                    _gl.uniform4f(location, value[0], value[1], value[2], value[3]);
                    break;
                case '1i':
                    _gl.uniform1i(location, value);
                    break;
                case '1f':
                    _gl.uniform1f(location, value);
                    break;
                case "1fv":
                    _gl.uniform1fv(location, value);
                    break;
                case "1iv":
                    _gl.uniform1iv(location, value);
                    break;
                case '2iv':
                    _gl.uniform2iv(location, value);
                    break;
                case '2fv':
                    _gl.uniform2fv(location, value);
                    break;
                case '3iv':
                    _gl.uniform3iv(location, value);
                    break;
                case '3fv':
                    _gl.uniform3fv(location, value);
                    break;
                case "4iv":
                    _gl.uniform4iv(location, value);
                    break;
                case "4fv":
                    _gl.uniform4fv(location, value);
                    break;
                case 'm2':
                    // The matrix must be created by glmatrix and can pass it directly.
                    _gl.uniformMatrix2fv(location, false, value);
                    break;
                case 'm3':
                    // The matrix must be created by glmatrix and can pass it directly.
                    _gl.uniformMatrix3fv(location, false, value);
                    break;
                case "m2v":
                    var size = 4;
                case "m3v":
                    var size = 9;
                case 'm4v':
                    var size = 16;
                    if (value instanceof Array) {
                        var array = new Float32Array(value.length * size);
                        var cursor = 0;
                        for (var i = 0; i < value.length; i++) {
                            var item = value[i];
                            for (var j = 0; j < item.length; j++) {
                                array[cursor++] = item[j];
                            }
                        }
                        _gl.uniformMatrix4fv(location, false, array);
                    // Raw value
                    }else if (value instanceof Float32Array) {   // ArrayBufferView
                        _gl.uniformMatrix4fv(location, false, value);
                    }
                    break;
            }
        },

        setUniformBySemantic : function(_gl, semantic, val) {
            var semanticInfo = this.attribSemantics[semantic];
            if (semanticInfo) {
                return this.setUniform(_gl, semanticInfo.type, semanticInfo.symbol, val);
            }
            return false;
        },
        /**
         * Enable the attributes passed in and disable the rest
         * Example Usage:
         * enableAttributes(_gl, "position", "texcoords")
         * OR
         * enableAttributes(_gl, ["position", "texcoords"])
         */
        enableAttributes : function(_gl, attribList) {
            
            var program = this.cache.get("program");

            var locationMap = this.cache.get("attriblocations");

            if (typeof(attribList) === "string") {
                attribList = Array.prototype.slice.call(arguments, 1);
            }

            var enabledAttributeListInContext = enabledAttributeList[_gl.__GLID__];
            if (! enabledAttributeListInContext) {
                enabledAttributeListInContext
                    = enabledAttributeList[_gl.__GLID__] 
                    = [];
            }
            var locationList = [];
            for (var i = 0; i < attribList.length; i++) {
                var symbol = attribList[i];
                if (!this.attributeTemplates[symbol]) {
                    locationList[i] = -1;
                    continue;
                }
                var location = locationMap[symbol];
                if (location === undefined) {
                    location = _gl.getAttribLocation(program, symbol);
                    // Attrib location is a number from 0 to ...
                    if (location === -1) {
                        locationList[i] = -1;
                        continue;
                    }
                    locationMap[symbol] = location;
                }
                locationList[i] = location;
                // 2 is going to enable(not enabled yet), 
                // 3 has beend enabled, and marked not to be disable
                if (!enabledAttributeListInContext[location]) {
                    enabledAttributeListInContext[location] = 2;
                } else {
                    enabledAttributeListInContext[location] = 3;
                }
            }

            for (var i = 0; i < enabledAttributeListInContext.length; i++) {
                switch(enabledAttributeListInContext[i]){
                    case 2:
                        _gl.enableVertexAttribArray(i);
                        enabledAttributeListInContext[i] = 1;
                        break;
                    case 3:
                        enabledAttributeListInContext[i] = 1;
                        break;
                    // Expired
                    case 1:
                        _gl.disableVertexAttribArray(i);
                        enabledAttributeListInContext[i] = 0;
                        break;
                }
            }

            return locationList;
        },

        _parseImport : function() {

            this._vertexProcessedWithoutDefine = Shader.parseImport(this.vertex);
            this._fragmentProcessedWithoutDefine = Shader.parseImport(this.fragment);

        },

        _addDefine : function() {

            // Add defines
            // VERTEX
            var defineStr = [];
            for (var lightType in this.lightNumber) {
                var count = this.lightNumber[lightType];
                if (count > 0) {
                    defineStr.push("#define "+lightType.toUpperCase()+"_NUMBER "+count);
                }
            }
            for (var symbol in this._textureStatus) {
                var status = this._textureStatus[symbol];
                if (status.enabled) {
                    defineStr.push("#define "+symbol.toUpperCase()+"_ENABLED");
                }
            }
            // Custom Defines
            for (var symbol in this.vertexDefines) {
                var value = this.vertexDefines[symbol];
                if (value === null) {
                    defineStr.push("#define "+symbol);
                }else{
                    defineStr.push("#define "+symbol+" "+value.toString());
                }
            }
            this._vertexProcessed = defineStr.join("\n") + "\n" + this._vertexProcessedWithoutDefine;

            // FRAGMENT
            defineStr = [];
            for (var lightType in this.lightNumber) {
                var count = this.lightNumber[lightType];
                if (count > 0) {
                    defineStr.push("#define "+lightType.toUpperCase()+"_NUMBER "+count);
                }
            }
            for (var symbol in this._textureStatus) {
                var status = this._textureStatus[symbol];
                if (status.enabled) {
                    defineStr.push("#define "+symbol.toUpperCase()+"_ENABLED");
                }
            }
            // Custom Defines
            for (var symbol in this.fragmentDefines) {
                var value = this.fragmentDefines[symbol];
                if (value === null) {
                    defineStr.push("#define "+symbol);
                }else{
                    defineStr.push("#define "+symbol+" "+value.toString());
                }
            }
            var tmp = defineStr.join("\n") + "\n" + this._fragmentProcessedWithoutDefine;
            
            // Add precision
            this._fragmentProcessed = ['precision', this.precision, 'float'].join(' ')+';\n' + tmp;
        },

        _parseUniforms : function() {
            var uniforms = {};
            var self = this;
            var shaderType = "vertex";
            this._uniformList = [];

            this._vertexProcessedWithoutDefine = this._vertexProcessedWithoutDefine.replace(uniformRegex, _uniformParser);
            shaderType = "fragment";
            this._fragmentProcessedWithoutDefine = this._fragmentProcessedWithoutDefine.replace(uniformRegex, _uniformParser);

            self.matrixSemanticKeys = Object.keys(this.matrixSemantics);

            function _uniformParser(str, type, symbol, isArray, semanticWrapper, semantic) {
                if (type && symbol) {
                    var uniformType = uniformTypeMap[type];
                    var isConfigurable = true;
                    if (uniformType) {
                        self._uniformList.push(symbol);
                        if (type === "sampler2D" || type === "samplerCube") {
                            // Texture is default disabled
                            self._textureStatus[symbol] = {
                                enabled : false,
                                shaderType : shaderType
                            };
                        }
                        if (isArray) {
                            uniformType += 'v';
                        }
                        if (semantic) {
                            // This case is only for SKIN_MATRIX
                            if (attribSemantics.indexOf(semantic) >= 0) {
                                self.attribSemantics[semantic] = {
                                    symbol : symbol,
                                    type : uniformType
                                }
                                isConfigurable = false;
                            }
                            else if (matrixSemantics.indexOf(semantic) >= 0) {
                                var isTranspose = false;
                                var semanticNoTranspose = semantic;
                                if (semantic.match(/TRANSPOSE$/)) {
                                    isTranspose = true;
                                    semanticNoTranspose = semantic.slice(0, -9)
                                }
                                self.matrixSemantics[semantic] = {
                                    symbol : symbol,
                                    type : uniformType,
                                    isTranspose : isTranspose,
                                    semanticNoTranspose : semanticNoTranspose
                                }
                                isConfigurable = false;
                            }
                            else {
                                // The uniform is not configurable, which means it will not appear
                                // in the material uniform properties
                                if (semantic === "unconfigurable") {
                                    isConfigurable = false;
                                }else{
                                    var defaultValueFunc = self._parseDefaultValue(type, semantic);
                                    if (! defaultValueFunc)
                                        throw new Error('Unkown semantic "' + semantic + '"');
                                    else
                                        semantic = "";
                                }
                            }
                        }
                        if (isConfigurable) {
                            uniforms[symbol] = {
                                type : uniformType,
                                value : isArray ? uniformValueConstructor['array'] : (defaultValueFunc || uniformValueConstructor[type]),
                                semantic : semantic || null
                            }
                        }
                    }
                    return ["uniform", type, symbol, isArray].join(" ")+";\n";
                }
            }

            this.uniformTemplates = uniforms;
        },

        _parseDefaultValue : function(type, str) {
            var arrayRegex = /\[\s*(.*)\s*\]/
            if (type === "vec2" ||
                type === "vec3" ||
                type === "vec4") {
                var arrayStr = arrayRegex.exec(str)[1];
                if (arrayStr) {
                    var arr = arrayStr.split(/\s*,\s*/);
                    return function() {
                        return new Float32Array(arr);
                    }
                }else{
                    // Invalid value
                    return;
                }
            }
            else if (type === "bool") {
                return function() {
                    return str.toLowerCase() === "true" ? true : false;
                }
            }
            else if (type === "float") {
                return function() {
                    return parseFloat(str);
                }
            }
        },

        // Create a new uniform instance for material
        createUniforms : function() {
            var uniforms = {};
            
            for (var symbol in this.uniformTemplates){
                var uniformTpl = this.uniformTemplates[symbol];
                uniforms[symbol] = {
                    type : uniformTpl.type,
                    value : uniformTpl.value()
                }
            }
            return uniforms;
        },

        _parseAttributes : function() {
            var attributes = {};
            var self = this;
            this._vertexProcessedWithoutDefine = this._vertexProcessedWithoutDefine.replace(attributeRegex, _attributeParser);

            function _attributeParser(str, type, symbol, semanticWrapper, semantic) {
                if (type && symbol) {
                    var size = 1;
                    switch (type) {
                        case "vec4":
                            size = 4;
                            break;
                        case "vec3":
                            size = 3;
                            break;
                        case "vec2":
                            size = 2;
                            break;
                        case "float":
                            size = 1;
                            break;
                    }

                    attributes[symbol] = {
                        // Force float
                        type : "float",
                        size : size,
                        semantic : semantic || null
                    }

                    if (semantic) {
                        if (attribSemantics.indexOf(semantic) < 0) {
                            throw new Error('Unkown semantic "' + semantic + '"');
                        }else{
                            self.attribSemantics[semantic] = {
                                symbol : symbol,
                                type : type
                            }
                        }
                    }
                }

                return ["attribute", type, symbol].join(" ")+";\n";
            }

            this.attributeTemplates = attributes;
        },

        _parseDefines : function() {
            var self = this;
            var shaderType = 'vertex';
            this._vertexProcessedWithoutDefine = this._vertexProcessedWithoutDefine.replace(defineRegex, _defineParser);
            shaderType = 'fragment';
            this._fragmentProcessedWithoutDefine = this._fragmentProcessedWithoutDefine.replace(defineRegex, _defineParser);

            function _defineParser(str, symbol, value) {
                var defines = shaderType === 'vertex' ? self.vertexDefines : self.fragmentDefines;
                if (!defines[symbol]) { // Haven't been defined by user
                    defines[symbol] = value ? parseFloat(value) : null;

                }
                return '';
            }
        },

        _buildProgram : function(_gl, vertexShaderString, fragmentShaderString) {

            if (this.cache.get("program")) {
                _gl.deleteProgram(this.cache.get("program"));
            }
            var program = _gl.createProgram();

            try {

                var vertexShader = this._compileShader(_gl, "vertex", vertexShaderString);
                var fragmentShader = this._compileShader(_gl, "fragment", fragmentShaderString);
                _gl.attachShader(program, vertexShader);
                _gl.attachShader(program, fragmentShader);
                // Force the position bind to index 0;
                if (this.attribSemantics['POSITION']) {
                    _gl.bindAttribLocation(program, 0, this.attribSemantics['POSITION'].symbol);
                }
                _gl.linkProgram(program);

                if (!_gl.getProgramParameter(program, _gl.LINK_STATUS)) {
                    throw new Error("Could not initialize shader\n" + "VALIDATE_STATUS: " + _gl.getProgramParameter(program, _gl.VALIDATE_STATUS) + ", gl error [" + _gl.getError() + "]");
                }
                // Cache uniform locations
                for (var i = 0; i < this._uniformList.length; i++) {
                    var uniformSymbol = this._uniformList[i];
                    var locationMap = this.cache.get("locations");
                    locationMap[uniformSymbol] = _gl.getUniformLocation(program, uniformSymbol);
                }

            } catch(e) {
                if (errorShader[this.__GUID__]) {
                    return;
                }
                errorShader[this.__GUID__] = this;
                throw e; 
            }

            _gl.deleteShader(vertexShader);
            _gl.deleteShader(fragmentShader);

            this.cache.put("program", program);
        },

        _compileShader : function(_gl, type, shaderString) {
            var shader = _gl.createShader(type === "fragment" ? _gl.FRAGMENT_SHADER : _gl.VERTEX_SHADER);
            _gl.shaderSource(shader, shaderString);
            _gl.compileShader(shader);

            if (!_gl.getShaderParameter(shader, _gl.COMPILE_STATUS)) {
                throw new Error([_gl.getShaderInfoLog(shader), addLineNumbers(shaderString)].join("\n"));
            }
            return shader;
        },

        clone : function() {
            var shader = new Shader({
                vertex : this.vertex,
                fragment : this.fragment,
                vertexDefines : _.clone(this.vertexDefines),
                fragmentDefines : _.clone(this.fragmentDefines)
            });
            for (var name in this._textureStatus) {
                shader._textureStatus[name] = _.clone(this._textureStatus[name]);
            }
            return shader;
        },

        dispose : function(_gl) {
            this.cache.use(_gl.__GLID__);
            if (program) {
                var program = this.cache.get('program');
            }
            _gl.deleteProgram(program);
            this.cache.deleteContext(_gl.__GLID__);
            this._locations = {};
        }
    });
    
    function getCacheSchema() {
        return {
            "locations" : {},
            "attriblocations" : {}
        }
    }

    // some util functions
    function addLineNumbers(string) {
        var chunks = string.split("\n");
        for (var i = 0, il = chunks.length; i < il; i ++) {
            // Chrome reports shader errors on lines
            // starting counting from 1
            chunks[i] = (i + 1) + ": " + chunks[i];
        }
        return chunks.join("\n");
    }

    var importRegex = /(@import)\s*([0-9a-zA-Z_\-\.]*)/g;
    Shader.parseImport = function(shaderStr) {
        shaderStr = shaderStr.replace(importRegex, function(str, importSymbol, importName) {
            if (_source[importName]) {
                // Recursively parse
                return Shader.parseImport(_source[importName]);
            }
        })
        return shaderStr;
    }

    var exportRegex = /(@export)\s*([0-9a-zA-Z_\-\.]*)\s*\n([\s\S]*?)@end/g;
    // Import the shader to library and chunks
    Shader.import = function(shaderStr) {
        shaderStr.replace(exportRegex, function(str, exportSymbol, exportName, code) {
            _source[exportName] = code;
            return code;
        })
    }

    // Library to store all the loaded shader strings
    var _source = {};

    Shader.source = function(name) {
        var shaderStr = _source[name];
        if (! shaderStr) {
            console.warn('Shader "' + name + '" not existed in library');
            return;
        }
        return shaderStr;
    }

    return Shader;
})