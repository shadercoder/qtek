@export buildin.basic.vertex

uniform mat4 worldViewProjection : WORLDVIEWPROJECTION;

uniform vec2 uvRepeat : [1.0, 1.0];

attribute vec2 texcoord : TEXCOORD_0;
attribute vec3 position : POSITION;

attribute vec3 barycentric;

#ifdef SKINNING
attribute vec3 weight : WEIGHT;
attribute vec4 joint : JOINT;

uniform mat4 invBindMatrix[JOINT_NUMBER] : INV_BIND_MATRIX;
#endif

varying vec2 v_Texcoord;
varying vec3 v_Barycentric;

void main(){

    vec3 skinnedPosition = position;

    #ifdef SKINNING
        mat4 skinMatrix;
        if (joint.x >= 0.0){
            skinMatrix = invBindMatrix[int(joint.x)] * weight.x;
        }
        if (joint.y >= 0.0){
            skinMatrix += invBindMatrix[int(joint.y)] * weight.y;
        }
        if (joint.z >= 0.0){
            skinMatrix += invBindMatrix[int(joint.z)] * weight.z;
        }
        if (joint.w >= 0.0){
            skinMatrix += invBindMatrix[int(joint.w)] * (1.0-weight.x-weight.y-weight.z);
        }
        skinnedPosition = (skinMatrix * vec4(position, 1.0)).xyz;
    #endif

    v_Texcoord = texcoord * uvRepeat;
    v_Barycentric = barycentric;

    gl_Position = worldViewProjection * vec4(skinnedPosition, 1.0);
}

@end




@export buildin.basic.fragment

varying vec2 v_Texcoord;
uniform sampler2D diffuseMap;
uniform vec3 color : [1.0, 1.0, 1.0];
uniform float alpha : 1.0;

// Uniforms for wireframe
uniform float lineWidth : 0.0;
uniform vec3 lineColor : [0.0, 0.0, 0.0];
varying vec3 v_Barycentric;

#extension GL_OES_standard_derivatives : enable
@import buildin.util.edge_factor

void main(){

    gl_FragColor = vec4(color, alpha);
    
    #ifdef DIFFUSEMAP_ENABLED
        vec4 tex = texture2D( diffuseMap, v_Texcoord );

        #ifdef RGBE_ENCODING
            // http://www.graphics.cornell.edu/~bjw/rgbe.html
            // http://www.contrib.andrew.cmu.edu/~yihuang/radiance_pic/Real%20Pixels%20-%20Greg%20Ward.pdf
            if (tex.a <= 0.) {
                tex.rgb = vec3(0.0);
            }
            else {
                float e = floor(tex.a * 255.0 + 0.5);
                float f = pow(2.0, (e - 128.0));
                tex.rgb += 0.5 / 256.0;
                tex.rgb *= f;
                tex.rgb /= 60.0;
                tex.rgb = pow(tex.rgb, vec3(2.2));
                // tex.rgb *= pow(2.0, -6.0);
            }
        #elif defined(DIFFUSEMAP_USE_ALPHA)
            gl_FragColor.a = tex.a;
        #endif

        gl_FragColor.rgb *= tex.rgb;
    #endif

    if( lineWidth > 0.01){
        gl_FragColor.rgb = gl_FragColor.rgb * mix(lineColor, vec3(1.0), edgeFactor(lineWidth));
    }
}

@end